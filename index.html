<html>

<title>conversion</title>
<body>
    <script>
        function checkFile() {
            var fileElement = document.getElementById("upload");
            var fileExtension = "";
            if (fileElement.value.lastIndexOf(".") > 0) {
                fileExtension = fileElement.value.substring(fileElement.value.lastIndexOf(".") + 1, fileElement.value.length);
            }
            if (fileExtension.toLowerCase() == "funscript") {
                return true;
            }
            else {
                alert("You must select a funscript file for upload");
                return false;
            }
        }
    </script>
    <form enctype="multipart/form-data">
        
        <div><label for="pattern-generation-rate">pattern-generation-rate:</label></label><input id="pattern-generation-rate" type="text" value="100"></input></div>
        <div><label for="pattern-generation-tick-max-change">pattern-generation-tick-max-change:</label></label><input id="pattern-generation-tick-max-change" type="text" value="10"></input></div>

        <div id="uploaddiv"><input id="upload" type=file   accept=".funscript" name="files[]" size=30 onchange="checkFile();" /></div>
        <p>Conversion:</p>
        <input type="radio" name="conversion" value="intensity" checked="true" />Intensity
        <input type="radio" name="conversion" value="dualchannel">Dual Channel
      
    </form>
    <button id="convert" value="Convert" onclick="convert();" disabled="true">Convert</button>    
    <button id="reset" value="Reset" onclick="reset();" disabled="true">Reset</button>    

    <div id="downloads"></div>
     
        <script>
        var script = '';

        var funscript = null;
        function getMode() {
            var selectedAns;
            var questions = document.getElementsByName("conversion");
            for(var i = 0; i < questions.length; i++) {
                if(questions[i].checked == true) {
                    selectedAns = questions[i].value;
                    break;
                }
            }
            return selectedAns;
        }
        function reset() {
            document.getElementById('convert').disabled = true;
            document.getElementById('reset').disabled = true;
            document.getElementById("upload").files = null;
            document.getElementById("pattern-generation-rate").value = 100;
            var myDiv = document.getElementById("downloads");
            myDiv.innerHTML = ""
            var parent = document.getElementById('uploaddiv');
            var el = document.getElementById('upload');

            var newEl = document.createElement("input");
            newEl.setAttribute('type', 'file');
            newEl.setAttribute("id", "upload");
            newEl.setAttribute("size", 30);

            newEl.setAttribute("onsumbit", "return checkFile();");

            parent.removeChild(el);
            parent.appendChild(newEl)
        }

        function convert() {
            var file = document.getElementById("upload").files[0];
            const reader = new FileReader()
            reader.onload = event => {
               console.log(file.name);
               var baseFilename = file.name.replace(/\.[^/.]+$/, "")

               funscript = JSON.parse(reader.result);
               console.log(funscript);
               var mode = getMode();
               var myDiv = document.getElementById("downloads");
               myDiv.innerHTML = ""
               if(mode == 'dualchannel') {
                var channels = convertToDualChannelPattern(funscript.actions); // desired file content
                console.log(channels);
                script = channels;
                add('Download Channel A', "download('" + baseFilename + "-a.funscript', script.a)")
                add('Download Channel B', "download('" + baseFilename + "-b.funscript', script.b)")
                document.getElementById('reset').disabled = false;
               } else {
                script = intensityPattern(funscript.actions); // desired file content
                add('Download', "download('" + baseFilename + ".funscript', script)")
                document.getElementById('reset').disabled = false;
               }

           }
           reader.onerror = error => reject(error)
           reader.readAsText(file);
          }

          function add(name, onclick) {
                var element = document.createElement("input");
                element.setAttribute("type", "button");
                element.setAttribute("value", name);
                element.setAttribute("name", "button3");
                element.setAttribute("onclick", onclick);
                document.getElementById('downloads').appendChild(element);
          }

          function download(filename, data) {
            var c = document.createElement("a");
                c.download = filename;
                funscript.actions = data;
                var t = new Blob([JSON.stringify(funscript)], {
                type: "text/plain"
                });
                c.href = window.URL.createObjectURL(t);
                c.click();
          }
          function getVariable(name) {
            return document.getElementById(name).value;
          }
                  
          function statusText(text) {
            return console.log(text);
          }

          function convertToDualChannelPattern(actions) {
            var length = actions.slice(-1).pop().at;
            var updateRateMs = getVariable('pattern-generation-rate');

            var normalSamples = length / updateRateMs;
            var fadeTime = 3000;
            var fadeSamples = fadeTime / updateRateMs;

            var totalSamples = normalSamples + (fadeSamples * 2);
            var sample = 0;
            var actionIndex = 0;

            var a1 = actions[0];
            var a0 = a1;
            var ampFilter = 0;
            var doubletime = 0;
            var left = [];
            var right = [];
            var lastUpdatedPercent = -1;
            sample = a0.at / updateRateMs;
                while(sample < totalSamples) {
                    var ms = sample * updateRateMs;

                if(a1.at < ms && actionIndex < actions.length - 1) {
                    a0 = a1;
                    actionIndex++;
                    a1 = actions[actionIndex];
                }
                
                var dist = a1.at - a0.at;
                var distFromNow = a1.at - ms;
                
                var dpos = a1.pos - a0.pos;
                var alpha = Math.max(0, Math.min(1, (ms - a0.at) / dist)) || 0;
                var pos = Math.floor(a0.pos + dpos * alpha);
                var fade = 1;
                if(dist > fadeTime * 2) {
                    if(distFromNow < fadeTime) {
                        fade = Math.max(0, 1 - (distFromNow / fadeTime));
                    } else if(dist - distFromNow > fadeTime) {
                        fade = Math.max(0, 1 - ((dist - distFromNow - fadeTime)/fadeTime));
                    }
                }
                left.push({'pos': Math.floor((100-pos) * fade), 'at': ms});
                right.push({'pos': Math.floor(pos * fade), 'at': ms});
                var percent = Math.floor(sample/totalSamples*100);
                if(lastUpdatedPercent != percent) {
                    lastUpdatedPercent = percent;
                    statusText('Generating dual channel pattern: ' + percent + '%');
                }
                if(fade == 0) {
                    if(distFromNow - fadeTime > 0) {
                        var newSample = (a1.at - fadeTime) / updateRateMs;
                        if(newSample <= sample) {
                            sample++;
                        } else {
                            sample = newSample;
                        }
                    } else {
                        sample++;
                    }
                } else {
                    sample++;
                }
                }
            return { 'a': left, 'b': right};
            }

            function normalizePattern(newActions, max) {
                console.log('Normalizing (max was ' + max + ') ...')
                if(newActions) {
                    statusText('Normalizing pattern...')
                    for(i = 0; i<newActions.length; i++) {
                        newActions[i].pos = Math.floor(newActions[i].pos / max * 100);
                    }
                }

            }

        function smooth(actions, getPosition, updateText, normalize) {
            var length = actions.slice(-1).pop().at;

            var updateRateMs = getVariable('pattern-generation-rate');
            var maxIncreasePerSecond = 25;
            var maxSampleIncrease =  getVariable('pattern-generation-tick-max-change');
            var target = 0;
            var normalSamples = length / updateRateMs;
            
            var totalSamples = normalSamples;

            var current = 0;
            var actionIndex = 0;
            var lastUpdatedPercent = 0;

            var previousPosition = 0;
            var position = 0;
            var newActions = [];
            act0 = actions[0];
            act1 = actions[0];
            var newpositions = [];
            var max = 0;
            for(i = 0; i<actions.length-1; i++) {
                pos = getPosition(act0, act1);
                if(pos > max) {
                    max = pos;
                }
                newpositions.push({ 'at': act0.at, 'pos': pos});

                act0 = act1;
                act1 = actions[i+1];

            }
            if(normalize && max < 100) {
                normalizePattern(newpositions, max);
            }
            max = 0;
            var a1 = actions[0];
            var a0 = a1;
            var sample = (a0.at / updateRateMs) - (100 / maxSampleIncrease);

            while(sample < totalSamples) {
                var ms = sample * updateRateMs;
                if(a1.at < ms && actionIndex < newpositions.length - 1) {
                    var old = a1;
                    var positions = 0;
                    previousPosition = position;
                    while(a1.at < ms && actionIndex < newpositions.length - 1) {
                        a0 = a1;
                        actionIndex++;
                        a1 = newpositions[actionIndex];
                        positions += a1.pos * (a1.at - a0.at);
                    }
                    position = Math.floor(positions/(a1.at - old.at));
                }
                var distFromNow = a1.at - ms;
                var dpos = position - previousPosition;
                var steps = Math.ceil(Math.abs(dpos) / maxSampleIncrease);
                var samplesLeft = Math.floor(distFromNow / updateRateMs);
                var percent = Math.floor(sample/totalSamples*100);
                if(lastUpdatedPercent != percent) {
                    lastUpdatedPercent = percent;
                    statusText(updateText + percent + '%');
                }
                if(steps >= samplesLeft) {
                    target = position;
                    if(current != target) {
                        if(current < target) {
                            current += Math.min(target - current, maxSampleIncrease);
                        } else {
                            current -= Math.min(current - target, maxSampleIncrease);
                        }
                        current = Math.min(100, Math.max(0, current));
                        if(max < current) {
                            max = current;
                        }
                        newActions.push({ 'at': ms, 'pos': current});
                    }
                    sample++;
                } else {
                    var increase = (samplesLeft - steps + 1) > 1 ? samplesLeft - steps + 1 : 1;
                    sample += Math.floor(increase);
                }
            }
            
            console.log('Smoothed pattern');
            if(normalize && max < 100) {
                normalizePattern(newActions, max);
            }
            debug(newActions);
            return newActions;
        }

        function debug(message) {
                console.log(message);
        }

        function intensityPosition(a0, a1) {
            return Math.min(100, Math.floor(Math.abs((a1.pos - a0.pos) / (a1.at - a0.at)) * 100));
        }

        function intensityPattern(actions) {
            return smooth(actions, intensityPosition, 'Intensifying pattern: ', true);
        }

          function handleFileSelect(evt) {
              document.getElementById('convert').disabled = false;
          }
          document.getElementById('upload').addEventListener('change', handleFileSelect, false);
        </script>
        
</body>
</html>